How To Design Programs Notes

* Terms
Data -
Concrete interpretation -
Atomic Data - numbers, letters
Compound data - number series, trees

Operations
- Primitive Operations - + 1 - / for numbers
- Programs

Expressions - pg 43
- Atomic - numbers, variables
- Compound - "(" expr ")"

* Recipe
** Basic
1. Problem Analysis & Data Definition
2. Contract, Purpose & Effect Statements, Header
3. Examples
4. Function Template
5. Function Definition
6. Tests

** Designing Programs

| Phase    | Goal                       | Activity                             |
|----------+----------------------------+--------------------------------------|
| Contract | to name the function;      | choose a name that fits the problem  |
| Purpose  | to specify its classes of  | • study the problem for clues on     |
| and      | input data and its         | how many unknown U givens" the       |
| Header   | class of output data;      | function consumes . pick one         |
|          | to describe its purpose;   | variable per input; if possible, use |
|          | to formulate a header      | names that are mentioned for the     |
|          |                            | U givens" in the problem statement   |
|          |                            | • describe what the function should  |
|          |                            | produce using the chosen variables   |
|          |                            | names . formulate the contract and   |
|          |                            | header:                              |
|          |                            | ;; name: number ... -> number        |
|          |                            | ;; to compute ... from xl ...        |
|          |                            | (defn [name (xl ... ) ... )          |
|          |                            |                                      |
|----------+----------------------------+--------------------------------------|
| Examples | to characterize the input- | search the problem statement for     |
|          | output relationship via    | examples . work through the          |
|          | examples                   | examples . validate the results, if  |
|          |                            | possible . make up examples          |
|----------+----------------------------+--------------------------------------|
| Body     | to define the function     | formulate how the function           |
|          |                            | computes its results . develop a     |
|          |                            | Scheme expression that uses          |
|          |                            | Scheme's primitive operations,       |
|          |                            | other functions, and the variables . |
|          |                            | translate the mathematical           |
|          |                            | expressions in the problem           |
|          |                            | statement, when available            |
|----------+----------------------------+--------------------------------------|
| Test     | to discover mistakes       | apply the function to the inputs of  |
|          | (Utypos" and logic)        | the examples . check that the        |
|          |                            | outputs are as predicted             |
|----------+----------------------------+--------------------------------------|


** 
** Designing Conditional Functions

** Designing Functions for Compound Data

** Designing Functions for Mixed Data

** Designing Functions for Self-Referential Data Definitions

** Designing Complex Programs

** Designing Functions for Mutually Referential Definitions

** Designing Functions that Consume Two Complex Inputs

** Designing Abstractions with Functions-as-Values

* Spec
** example

(ns my-project.spec
  (:require [clojure.spec.alpha :as s]
            [clojure.spec.gen.alpha :as gen]
            [clojure.spec.test.alpha :as stest]))

;;; scaling ingredient

;; data definition

;; spec describing an ingredient
(s/def ::ingredient (s/keys :req [::name ::quantity ::unit]))
(s/def ::name     string?)
(s/def ::quantity number?)
(s/def ::unit     keyword?)

;; Function spec
(declare scale-ingredient)
(s/fdef scale-ingredient
  :args (s/cat :ingredient ::ingredient :factor number?)
  :ret ::ingredient)

(defn scale-ingredient [ingredient factor]
  (update ingredient :quantity * factor))

** 
