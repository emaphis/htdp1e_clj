How To Design Programs Notes

* Terms
Data -
Concrete interpretation -
Atomic Data - numbers, letters
Compound data - number series, trees

Operations
- Primitive Operations - + 1 - / for numbers
- Programs

Expressions - pg 43
- Atomic - numbers, variables
- Compound - "(" expr ")"

* Recipe
** Basic
1. Problem Analysis & Data Definition
2. Contract, Purpose & Effect Statements, Header
3. Examples
4. Function Template
5. Function Definition
6. Tests

** Designing Programs

| Phase    | Goal                       | Activity                             |
|----------+----------------------------+--------------------------------------|
| Contract | * to name the function;    | * choose a name that fits the problem |
| Purpose  | * to specify its classes   | * study the problem for clues on     |
| and      | of input data and its      | how many unknown U givens" the       |
| Header   | class of output data;      | function consumes * pick one         |
|          | * to describe its purpose; | variable per input; if possible, use |
|          | * to formulate a header    | names that are mentioned for the     |
|          |                            | U givens" in the problem statement   |
|          |                            | * describe what the function should  |
|          |                            | produce using the chosen variables   |
|          |                            | names . formulate the contract and   |
|          |                            | header:                              |
|          |                            | ;; name: number ... -> number        |
|          |                            | ;; to compute ... from xl ...        |
|          |                            | (defn [name (xl ... ) ... )          |
|          |                            |                                      |
|----------+----------------------------+--------------------------------------|
| Examples | * to characterize the      | search the problem statement for     |
|          | input-output relationship  | examples * work through the          |
|          | via examples               | examples * validate the results, if  |
|          |                            | possible * make up examples          |
|----------+----------------------------+--------------------------------------|
| Body     | * to define the function   | formulate how the function           |
|          |                            | computes its results * develop a     |
|          |                            | Scheme expression that uses          |
|          |                            | Scheme's primitive operations,       |
|          |                            | other functions, and the variables . |
|          |                            | translate the mathematical           |
|          |                            | expressions in the problem           |
|          |                            | statement, when available            |
|----------+----------------------------+--------------------------------------|
| Test     | * to discover mistakes     | apply the function to the inputs of  |
|          | (Utypos" and logic)        | the examples * check that the        |
|          |                            | outputs are as predicted             |
|----------+----------------------------+--------------------------------------|

GUIDELINE ON AUXILIARY FUNCTIONS
Formulate auxiliary function definitions for every dependency between
quantities mentioned in the problem statement or discovered
with example calculations.

GUIDELINE ON VARIABLE DEFINITIONS
Give names to frequently used constants and use the names instead
of the constants in programs.

** 
** Designing Conditional Functions
Data Analysis and Definition: After we determine that a problem statement
deals with distinct situations, we must identify all of them. The
second step is a DATA DEFINITION, an idea that we will explore a lot
more.

Figure 6: Designing the body of a conditional function
(Use with the recipe in figure 4

|------------+------------------------------+------------------------------------------|
| Phase      | Goal                         | Activity                                 |
|------------+------------------------------+------------------------------------------|
| Data       | * to determine the distinct  | * inspect the problem statement for      |
| Analysis   | situations a function deals  | distinct situations                      |
|            | with                         | * enumerate all possible situations      |
|------------+------------------------------+------------------------------------------|
| Examples   | * to provide an example      | * choose at least one example            |
|            | per situation                | per situation                            |
|            |                              | * for intervals or enumerations,         |
|            |                              | the examples must include                |
|            |                              | borderline cases                         |
|------------+------------------------------+------------------------------------------|
| Body (1)   | * to formulate a conditional | * write down the skeleton of a cond      |
| Conditions | expression                   | expression, with one clause per          |
|            |                              | situation                                |
|            |                              | * formulate one condition per situation, |
|            |                              | using the parameters                     |
|            |                              | * ensure that the conditions distinguish |
|            |                              | the examples appropriately               |
|------------+------------------------------+------------------------------------------|
| Body (2)   | * to formulate the answers   | * deal with each cond-line separately    |
| Answers    | for the cond-clauses         | * assume the condition holds and develop |
|            |                              | a Scheme expression that computes the    |
|            |                              | appropriate answer for this case         |
|------------+------------------------------+------------------------------------------|


** Designing Functions for Compound Data

Figure 12: Designing a function for compound data
(Refines the recipe in figure 4 (pg. 21))

| Phase    | Goal                         | Activity                             |   |   |
|----------+------------------------------+--------------------------------------+---+---|
| Data     | * to formulate a data        | * determine how many pieces of data  |   |   |
| Analysis | definition                   | describe the "interesting" aspects   |   |   |
| and      |                              | of the objects mentioned in the      |   |   |
| Design   |                              | problem statement.                   |   |   |
|          |                              | * add a structure definition and a   |   |   |
|          |                              | data definition (for each class of   |   |   |
|          |                              | problem object)                      |   |   |
|----------+------------------------------+--------------------------------------+---+---|
| Contract | * to name the function;      | * name the function, the classes     |   |   |
| Purpose  | * to specify its classes of  | of input data, the class of output   |   |   |
| and      | input data and its           | data, and specify its purpose:       |   |   |
| Header   | class of output data;        | ;; name : inl in2 ... -> out         |   |   |
|          | * to describe its purpose;   | ;; to compute ... from xl ...        |   |   |
|          | * to formulate a header      | (defn name [x1 x2 ...] ...)          |   |   |
|----------+------------------------------+--------------------------------------+---+---|
| Examples | * to characterize the input- | * search the problem statement for   |   |   |
|          | output relationship via      | examples                             |   |   |
|          | examples.                    | * work through the examples          |   |   |
|          |                              | * validate the results, if possible  |   |   |
|          |                              | * make up examples                   |   |   |
|----------+------------------------------+--------------------------------------+---+---|
| Template | * to formulate an outline    | * for those parameters that stand    |   |   |
|          |                              | for compound values, annotate the    |   |   |
|          |                              | the body with selector expressions   |   |   |
|          |                              | * if with selector expressions,      |   |   |
|          |                              | annotate all appropriate branches.   |   |   |
|----------+------------------------------+--------------------------------------+---+---|
| Body     | * to define the function     | * develop a Clojure expression that  |   |   |
|          |                              | uses Clojure's primitive operations, |   |   |
|          |                              | other functions, selector            |   |   |
|          |                              | expressions, and the variables.      |   |   |
|----------+------------------------------+--------------------------------------+---+---|
| Test     | * to discover mistakes       | * apply the function to the inputs   |   |   |
|          | ("typos" and logic)          | of the examples                      |   |   |
|          |                              | * check that the outputs are as      |   |   |
|          |                              | expected.                            |   |   |
|----------+------------------------------+--------------------------------------+---+---|


*** Example 1 - Student
;; consider functions that process student records at a school. If
;; a student's interesting properties for a school are

;; 1. the first name,
;; 2. the last name, and
;; 3. the name of the home-room teacher

;; Data Definition

;; A `student` is a map
;; make-student : 'symbol symbol symbol -> student
(defn make-student [last first teacher]
  {:last last :first first :teacher teacher})

;; Contract:
;; subst-teacher : student symbol -> student

;; Purpose:
;; Create a student map with a new teacher name if the teacher's
;; name matches 'Fri.

;; Examples:
;; (= (make-student 'Find 'Matthew 'Amanda)
;;    (subst-teacher (make-student 'Find 'Matthew 'Amanda) 'Elise))

;; (= (make-student 'Matthew 'Elsie)
;;    (subst-teacher (make-student 'Find 'Matthew 'Fritz) 'Elsie))

;; Template
(defn process-student [a-student]
  ,,, (:last a-student),,,
  ,,, (:first a-student),,,
  ,,, (:teacher a-student) ,,,)

;; Definition:
(defn subst-teacher [a-student a-teacher]
  (cond
    (= (:teacher a-student) 'Fritz)
    (make-student (:last a-student)
                  (:first a-student)
                  a-teacher)
    :else a-student))

;; Tests
(deftest test-subst-teacher
  (is (= (make-student 'Find 'Matthew 'Amanda)
         (subst-teacher (make-student 'Find 'Matthew 'Amanda) 'Elise)))
  (is (= (make-student 'Find 'Matthew 'Elsie)
         (subst-teacher (make-student 'Find 'Matthew 'Fritz) 'Elsie))))



** Designing Functions for Mixed Data

** Designing Functions for Self-Referential Data Definitions

** Designing Complex Programs

** Designing Functions for Mutually Referential Definitions

** Designing Functions that Consume Two Complex Inputs

** Designing Abstractions with Functions-as-Values

* Spec
** example

(ns my-project.spec
  (:require [clojure.spec.alpha :as s]
            [clojure.spec.gen.alpha :as gen]
            [clojure.spec.test.alpha :as stest]))

;;; scaling ingredient

;; data definition

;; spec describing an ingredient
(s/def ::ingredient (s/keys :req [::name ::quantity ::unit]))
(s/def ::name     string?)
(s/def ::quantity number?)
(s/def ::unit     keyword?)

;; Function spec
(declare scale-ingredient)
(s/fdef scale-ingredient
  :args (s/cat :ingredient ::ingredient :factor number?)
  :ret ::ingredient)

(defn scale-ingredient [ingredient factor]
  (update ingredient :quantity * factor))

** 
