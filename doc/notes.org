How To Design Programs Notes

* Terms
Data -
Concrete interpretation -
Atomic Data - numbers, letters
Compound data - number series, trees

Operations
- Primitive Operations - + 1 - / for numbers
- Programs

Expressions - pg 43
- Atomic - numbers, variables
- Compound - "(" expr ")"

* Recipe
** Basic
1. Problem Analysis & Data Definition
2. Contract, Purpose & Effect Statements, Header
3. Examples
4. Function Template
5. Function Definition
6. Tests

** Designing Programs

** Designing Conditional Functions

** Designing Functions for Compound Data

** Designing Functions for Mixed Data

** Designing Functions for Self-Referential Data Definitions

** Designing Complex Programs

** Designing Functions for Mutually Referential Definitions

** Designing Functions that Consume Two Complex Inputs

** Designing Abstractions with Functions-as-Values

* Spec
** example

(ns my-project.spec
  (:require [clojure.spec.alpha :as s]
            [clojure.spec.gen.alpha :as gen]
            [clojure.spec.test.alpha :as stest]))

;;; scaling ingredient

;; data definition

;; spec describing an ingredient
(s/def ::ingredient (s/keys :req [::name ::quantity ::unit]))
(s/def ::name     string?)
(s/def ::quantity number?)
(s/def ::unit     keyword?)

;; Function spec
(declare scale-ingredient)
(s/fdef scale-ingredient
  :args (s/cat :ingredient ::ingredient :factor number?)
  :ret ::ingredient)

(defn scale-ingredient [ingredient factor]
  (update ingredient :quantity * factor))

** 
