How To Design Programs Notes

* Terms
Data -
Concrete interpretation -
Atomic Data - numbers, letters
Compound data - number series, trees

Operations
- Primitive Operations - + 1 - / for numbers
- Programs

Expressions - pg 43
- Atomic - numbers, variables
- Compound - "(" expr ")"

* Recipe
** Basic
1. Problem Analysis & Data Definition
2. Contract, Purpose & Effect Statements, Header
3. Examples
4. Function Template
5. Function Definition
6. Tests

** Designing Programs

| Phase    | Goal                       | Activity                             |
|----------+----------------------------+--------------------------------------|
| Contract | to name the function;      | choose a name that fits the problem  |
| Purpose  | to specify its classes of  | • study the problem for clues on     |
| and      | input data and its         | how many unknown U givens" the       |
| Header   | class of output data;      | function consumes . pick one         |
|          | to describe its purpose;   | variable per input; if possible, use |
|          | to formulate a header      | names that are mentioned for the     |
|          |                            | U givens" in the problem statement   |
|          |                            | • describe what the function should  |
|          |                            | produce using the chosen variables   |
|          |                            | names . formulate the contract and   |
|          |                            | header:                              |
|          |                            | ;; name: number ... -> number        |
|          |                            | ;; to compute ... from xl ...        |
|          |                            | (defn [name (xl ... ) ... )          |
|          |                            |                                      |
|----------+----------------------------+--------------------------------------|
| Examples | to characterize the input- | search the problem statement for     |
|          | output relationship via    | examples . work through the          |
|          | examples                   | examples . validate the results, if  |
|          |                            | possible . make up examples          |
|----------+----------------------------+--------------------------------------|
| Body     | to define the function     | formulate how the function           |
|          |                            | computes its results . develop a     |
|          |                            | Scheme expression that uses          |
|          |                            | Scheme's primitive operations,       |
|          |                            | other functions, and the variables . |
|          |                            | translate the mathematical           |
|          |                            | expressions in the problem           |
|          |                            | statement, when available            |
|----------+----------------------------+--------------------------------------|
| Test     | to discover mistakes       | apply the function to the inputs of  |
|          | (Utypos" and logic)        | the examples . check that the        |
|          |                            | outputs are as predicted             |
|----------+----------------------------+--------------------------------------|

GUIDELINE ON AUXILIARY FUNCTIONS
Formulate auxiliary function definitions for every dependency between
quantities mentioned in the problem statement or discovered
with example calculations.

GUIDELINE ON VARIABLE DEFINITIONS
Give names to frequently used constants and use the names instead
of the constants in programs.

** 
** Designing Conditional Functions
Data Analysis and Definition: After we determine that a problem statement
deals with distinct situations, we must identify all of them. The
second step is a DATA DEFINITION, an idea that we will explore a lot
more.

Figure 6: Designing the body of a conditional function
(Use with the recipe in figure 4

|------------+-----------------------------+------------------------------------------|
| Phase      | Goal                        | Activity                                 |
|------------+-----------------------------+------------------------------------------|
| Data       | to determine the distinct   | * inspect the problem statement for      |
| Analysis   | situations a function deals | distinct situations                      |
|            | with                        | * enumerate all possible situations      |
|------------+-----------------------------+------------------------------------------|
| Examples   | to provide an example       | * choose at least one example            |
|            | per situation               | per situation                            |
|            |                             | * for intervals or enumerations,         |
|            |                             | the examples must include                |
|            |                             | borderline cases                         |
|------------+-----------------------------+------------------------------------------|
| Body (1)   | to formulate a conditional  | * write down the skeleton of a cond      |
| Conditions | expression                  | expression, with one clause per          |
|            |                             | situation                                |
|            |                             | * formulate one condition per situation, |
|            |                             | using the parameters                     |
|            |                             | * ensure that the conditions distinguish |
|            |                             | the examples appropriately               |
|------------+-----------------------------+------------------------------------------|
| Body (2)   | to formulate the answers    | * deal with each cond-line separately    |
| Answers    | for the cond-clauses        | * assume the condition holds and develop |
|            |                             | a Scheme expression that computes the    |
|            |                             | appropriate answer for this case         |
|------------+-----------------------------+------------------------------------------|


** Designing Functions for Compound Data

** Designing Functions for Mixed Data

** Designing Functions for Self-Referential Data Definitions

** Designing Complex Programs

** Designing Functions for Mutually Referential Definitions

** Designing Functions that Consume Two Complex Inputs

** Designing Abstractions with Functions-as-Values

* Spec
** example

(ns my-project.spec
  (:require [clojure.spec.alpha :as s]
            [clojure.spec.gen.alpha :as gen]
            [clojure.spec.test.alpha :as stest]))

;;; scaling ingredient

;; data definition

;; spec describing an ingredient
(s/def ::ingredient (s/keys :req [::name ::quantity ::unit]))
(s/def ::name     string?)
(s/def ::quantity number?)
(s/def ::unit     keyword?)

;; Function spec
(declare scale-ingredient)
(s/fdef scale-ingredient
  :args (s/cat :ingredient ::ingredient :factor number?)
  :ret ::ingredient)

(defn scale-ingredient [ingredient factor]
  (update ingredient :quantity * factor))

** 
